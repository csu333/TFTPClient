
// Content is generated by Claude Sonnet 4: https://claude.ai/public/artifacts/f60c48db-8a89-4c48-8a4a-bce7fee491ba
#include "TFTPClient.h"

#pragma region Constructors and Destructors
TFTPClient::TFTPClient() {
    _timeout = TFTP_TIMEOUT_MS; 
    _maxRetries = TFTP_MAX_RETRIES, 
    _lastErrorCode = 0;
    _initialized = false;
    _lastErrorMessage[0] = '\0';
    resetDownloadState();
    resetUploadState();
}

TFTPClient::~TFTPClient() {
    stop();
}
#pragma endregion

bool TFTPClient::initialize() {
    if (_initialized) {
        return true;
    }
    
    if (_udp.begin(0)) {  // Use random local port
        _initialized = true;
        setError(0, "OK");
        return true;
    } else {
        setError(-1, "Failed to initialize UDP");
        return false;
    }
}

#pragma region File exchange
bool TFTPClient::downloadFile(IPAddress serverIP, const char* filename, uint8_t* buffer, size_t bufferSize) {
    beginDownload(serverIP, filename);
    
    uint8_t blockBuffer[TFTP_DATA_SIZE];

    // Receive data packets
    while (_downloadActive) {
        int bytesRead = readBlock(blockBuffer, sizeof(blockBuffer));
        
        if (_totalBytesReceived >= bufferSize) {
            // Buffer overflow
            setError(-8, "Buffer overflow");
            return false;
        }
        
        if (bytesRead > 0) {
            memcpy(buffer + (_expectedBlock - 2) * TFTP_DATA_SIZE, blockBuffer, bytesRead);      
        } 
        
        if (bytesRead < TFTP_DATA_SIZE) {
            // Download completed
            setError(0, "Download completed successfully");
            return true;
        } 
    }

    return false;
}

bool TFTPClient::downloadFile(const char* serverHost, const char* filename, uint8_t* buffer, size_t bufferSize) {
    IPAddress serverIP;
    if (!resolveHostname(serverHost, serverIP)) {
        setError(-2, "Failed to resolve hostname");
        return false;
    }
    return downloadFile(serverIP, filename, buffer, bufferSize);
}

bool TFTPClient::downloadFileWithProgress(const char* serverHost, const char* filename, ProgressCallback callback) {
    IPAddress serverIP;
    if (!resolveHostname(serverHost, serverIP)) {
        setError(-2, "Failed to resolve hostname");
        return false;
    }
    return downloadFileWithProgress(serverIP, filename, callback);
}

bool TFTPClient::downloadFileWithProgress(IPAddress serverIP, const char* filename, ProgressCallback callback) {
    beginDownload(serverIP, filename);
    
    uint8_t blockBuffer[TFTP_DATA_SIZE];

    // Receive data packets
    while (_downloadActive) {
        int bytesRead = readBlock(blockBuffer, sizeof(blockBuffer));
        
        if (bytesRead > 0) {
            callback(blockBuffer, bytesRead);    
        } 
        
        if (bytesRead < TFTP_DATA_SIZE) {
            // Download completed
            setError(0, "Download completed successfully");
            return true;
        } 
    }

    return false;
}

int TFTPClient::peek() {
    if (_readBufferIndex < 0) {
        readBlock(_readBuffer, sizeof(_readBuffer));
    }

    return _readBuffer[_readBufferIndex];
}

int TFTPClient::read() {
    if (_readBufferIndex < 0) {
        readBlock(_readBuffer, sizeof(_readBuffer));
    }

    return _readBuffer[_readBufferIndex--];
}

size_t TFTPClient::readBytes(char *buffer, size_t length) {
    size_t bytesRead = 0;

    if (!_downloadActive) {
        return 0;
    }

    while (length > 0) {
        if (_readBufferIndex >= sizeof(_readBuffer) || _readBufferIndex <= 0) {
            int bytesReadBlock = readBlock(_readBuffer, sizeof(_readBuffer));
            if (bytesReadBlock < TFTP_DATA_SIZE) {
                setError(0, "Download completed successfully");
                _downloadActive = false;
            }
            _readBufferIndex = 0;
        }

        *buffer++ = (char)_readBuffer[_readBufferIndex++];
        bytesRead++;
        length--;
    }

    return bytesRead;
}

#pragma endregion

void TFTPClient::setMaxRetries(int retries) {
    _maxRetries = max(0, retries);
}

int TFTPClient::getLastErrorCode() {
    return _lastErrorCode;
}

const char* TFTPClient::getLastErrorMessage() {
    return _lastErrorMessage;
}

void TFTPClient::stop() {
    endDownload();  // End any active download
    endUpload();    // End any active upload
    if (_initialized) {
        _udp.stop();
        _initialized = false;
    }
}

// Private methods
#pragma region Private methods

bool TFTPClient::sendReadRequest(IPAddress serverIP, uint16_t port, const char* filename) {
    size_t filenameLen = strlen(filename);
    const char* mode = "octet";  // Binary mode
    size_t modeLen = strlen(mode);
    
    size_t packetSize = 2 + filenameLen + 1 + modeLen + 1;  // opcode + filename + null + mode + null
    uint8_t* packet = new uint8_t[packetSize];
    
    if (!packet) {
        setError(-9, "Memory allocation failed");
        return false;
    }
    
    // Build RRQ packet
    setUint16(packet, TFTP_RRQ);
    strcpy((char*)(packet + 2), filename);
    strcpy((char*)(packet + 2 + filenameLen + 1), mode);
    
    _udp.beginPacket(serverIP, port);
    size_t written = _udp.write(packet, packetSize);
    bool success = _udp.endPacket() && (written == packetSize);
    
    delete[] packet;
    return success;
}

bool TFTPClient::sendWriteRequest(IPAddress serverIP, uint16_t port, const char* filename) {
    size_t filenameLen = strlen(filename);
    const char* mode = "octet";  // Binary mode
    size_t modeLen = strlen(mode);
    
    size_t packetSize = 2 + filenameLen + 1 + modeLen + 1;  // opcode + filename + null + mode + null
    uint8_t* packet = new uint8_t[packetSize];
    
    if (!packet) {
        setError(-9, "Memory allocation failed");
        return false;
    }
    
    // Build WRQ packet
    setUint16(packet, TFTP_WRQ);
    strcpy((char*)(packet + 2), filename);
    strcpy((char*)(packet + 2 + filenameLen + 1), mode);
    
    _udp.beginPacket(serverIP, port);
    size_t written = _udp.write(packet, packetSize);
    bool success = _udp.endPacket() && (written == packetSize);
    
    delete[] packet;
    return success;
}

bool TFTPClient::receivePacket(uint8_t* buffer, size_t& packetSize, IPAddress& fromIP, uint16_t& fromPort, unsigned long timeout) {
    unsigned long startTime = millis();
    
    while (millis() - startTime < timeout) {
        int available = _udp.parsePacket();
        if (available > 0) {
            packetSize = min((uint)available, (uint)TFTP_PACKET_MAX_SIZE);
            fromIP = _udp.remoteIP();
            fromPort = _udp.remotePort();
            
            size_t bytesRead = _udp.read(buffer, packetSize);
            if (bytesRead == packetSize) {
                return true;
            }
        }
        delay(10);  // Small delay to prevent busy waiting
    }

    _downloadActive = false;
    
    return false;
}

void TFTPClient::resetDownloadState(bool keepStats) {
    _downloadActive = false;
    _serverIP = IPAddress(0, 0, 0, 0);
    _serverPort = 0;
    if (!keepStats) {
        _expectedBlock = 1;
        _totalBytesReceived = 0;
    }
    _readBufferIndex = -1;
    _downloadComplete = false;
}

void TFTPClient::resetUploadState() {
    _uploadActive = false;
    _uploadServerIP = IPAddress(0, 0, 0, 0);
    _uploadServerPort = 0;
    _nextUploadBlock = 1;
    _totalBytesSent = 0;
    _writeBufferIndex = 0;
    _uploadComplete = false;
}

// Active download management methods

bool TFTPClient::beginDownload(IPAddress serverIP, const char* filename) {
    if (!_initialized) {
        initialize();
    }
    
    if (_downloadActive) {
        setError(-10, "Download already active");
        return false;
    }
    
    resetDownloadState();
    _serverIP = serverIP;
    _downloadActive = true;
    
    // Send initial read request
    for (int retry = 0; retry <= _maxRetries; retry++) {
        if (sendReadRequest(_serverIP, TFTP_DEFAULT_PORT, filename)) {
            setError(0, "Download started successfully");
            return true;
        }
        if (retry < _maxRetries) {
            delay(100);
        }
    }
    
    setError(-4, "Failed to send read request after retries");
    return false;
}

bool TFTPClient::beginDownload(const char* serverHost, const char* filename) {
    IPAddress serverIP;
    if (!resolveHostname(serverHost, serverIP)) {
        setError(-2, "Failed to resolve hostname");
        return false;
    }
    return beginDownload(serverIP, filename);
}

int TFTPClient::readBlock(uint8_t* buffer, size_t bufferSize) {
    if (!_downloadActive) {
        setError(-11, "No active download");
        return -1;
    }
    
    if (_downloadComplete) {
        setError(0, "Download already completed");
        return 0;
    }
    
    if (!buffer || bufferSize < TFTP_DATA_SIZE) {
        setError(-3, "Invalid buffer parameters");
        return -1;
    }
    
    uint8_t packet[TFTP_PACKET_MAX_SIZE];
    size_t packetSize;
    IPAddress fromIP;
    uint16_t fromPort;
    
    // Receive data packet with retries
    bool packetReceived = false;
    for (int retry = 0; retry <= _maxRetries; retry++) {
        if (receivePacket(packet, packetSize, fromIP, fromPort, _timeout)) {
            packetReceived = true;
            break;
        }
        
        // Resend last ACK on timeout (except for first packet)
        if (_expectedBlock > 1 && retry < _maxRetries) {
            sendAck(_serverIP, _serverPort, _expectedBlock - 1);
        }
    }
    
    if (!packetReceived) {
        setError(-5, "Timeout waiting for data packet");
        return -1;
    }
    
    // Verify packet comes from correct server
    if (fromIP != _serverIP) {
        setError(-12, "Packet from unexpected IP");
        return -1;
    }
    
    // Update server port after first packet
    if (_expectedBlock == 1) {
        _serverPort = fromPort;
    } else if (fromPort != _serverPort) {
        setError(-13, "Packet from unexpected port");
        return -1;
    }
    
    // Parse packet
    if (packetSize < 4) {
        setError(-6, "Invalid packet size");
        return -1;
    }
    
    uint16_t opcode = getUint16(packet);
    
    if (opcode == TFTP_DATA) {
        uint16_t blockNumber = getUint16(packet + 2);
        
        // Check if this is the expected block
        if (blockNumber == _expectedBlock) {
            size_t dataSize = packetSize - 4;  // Subtract 4-byte header
            
            // Copy data to user buffer
            memcpy(buffer, packet + 4, dataSize);
            _totalBytesReceived += dataSize;
            
            // Send ACK
            if (!sendAck(_serverIP, _serverPort, blockNumber)) {
                setError(-8, "Failed to send ACK");
                return -1;
            }
            
            _expectedBlock++;
            
            // If data size is less than 512 bytes, this is the last packet
            if (dataSize < TFTP_DATA_SIZE) {
                _downloadComplete = true;
                setError(0, "Last block received");
            }
            
            return (int)dataSize;
            
        } else if (blockNumber == _expectedBlock - 1) {
            // Duplicate packet, resend ACK and try again
            sendAck(_serverIP, _serverPort, blockNumber);
            return readBlock(buffer, bufferSize);  // Recursive call to get next packet
        } else {
            setError(-14, "Unexpected block number");
            return -1;
        }
        
    } else if (opcode == TFTP_ERROR) {
        if (packetSize >= 5) {
            uint16_t errorCode = getUint16(packet + 2);
            _lastErrorCode = errorCode;
            
            // Extract error message
            size_t msgLen = min((uint)packetSize - 4, (uint)sizeof(_lastErrorMessage) - 1);
            memcpy(_lastErrorMessage, packet + 4, msgLen);
            _lastErrorMessage[msgLen] = '\0';
            
            resetDownloadState();
            return -1;
        }
    }
    
    setError(-15, "Unexpected packet type");
    return -1;
}

bool TFTPClient::endDownload() {
    if (_downloadActive) {
        resetDownloadState(true);
        return true;
    }
    return false;
}

int TFTPClient::available() {
    if (!_initialized) {
        return 0;
    }
    return _udp.available();
}

bool TFTPClient::isDownloadActive() {
    return _downloadActive;
}

bool TFTPClient::isDownloadComplete() {
    return _downloadComplete;
}

uint16_t TFTPClient::getCurrentBlockNumber() {
    return _expectedBlock;
}

size_t TFTPClient::getTotalBytesReceived() {
    return _totalBytesReceived;
}

// Active upload management methods

bool TFTPClient::beginUpload(IPAddress serverIP, const char* filename) {
    if (!_initialized) {
        initialize();
    }
    
    if (_uploadActive) {
        setError(-16, "Upload already active");
        return false;
    }
    
    if (_downloadActive) {
        setError(-17, "Cannot start upload while download is active");
        return false;
    }
    
    resetUploadState();
    _uploadServerIP = serverIP;
    _uploadActive = true;
    
    // Send write request (WRQ)
    for (int retry = 0; retry <= _maxRetries; retry++) {
        if (sendWriteRequest(_uploadServerIP, TFTP_DEFAULT_PORT, filename)) {
            // Wait for ACK of block 0 or ERROR
            uint8_t packet[TFTP_PACKET_MAX_SIZE];
            size_t packetSize;
            IPAddress fromIP;
            uint16_t fromPort;
            
            if (receivePacket(packet, packetSize, fromIP, fromPort, _timeout)) {
                if (fromIP == _uploadServerIP && packetSize >= 4) {
                    uint16_t opcode = getUint16(packet);
                    
                    if (opcode == TFTP_ACK) {
                        uint16_t blockNumber = getUint16(packet + 2);
                        if (blockNumber == 0) {
                            _uploadServerPort = fromPort;
                            setError(0, "Upload started successfully");
                            return true;
                        }
                    } else if (opcode == TFTP_ERROR) {
                        if (packetSize >= 5) {
                            uint16_t errorCode = getUint16(packet + 2);
                            _lastErrorCode = errorCode;
                            size_t msgLen = min((uint)packetSize - 4, (uint)sizeof(_lastErrorMessage) - 1);
                            memcpy(_lastErrorMessage, packet + 4, msgLen);
                            _lastErrorMessage[msgLen] = '\0';
                        } else {
                            setError(-18, "Server error response");
                        }
                        resetUploadState();
                        return false;
                    }
                }
            }
        }
        
        if (retry < _maxRetries) {
            delay(100);
        }
    }
    
    setError(-19, "Failed to start upload after retries");
    resetUploadState();
    return false;
}

bool TFTPClient::beginUpload(const char* serverHost, const char* filename) {
    IPAddress serverIP;
    if (!resolveHostname(serverHost, serverIP)) {
        setError(-2, "Failed to resolve hostname");
        return false;
    }
    return beginUpload(serverIP, filename);
}

size_t TFTPClient::write(uint8_t c) {
    _writeBuffer[_writeBufferIndex++] = c;
    if (_writeBufferIndex == TFTP_DATA_SIZE) {
        writeBlock(_writeBuffer, TFTP_DATA_SIZE);
        _writeBufferIndex = 0;
    }
    return 1;
}

size_t TFTPClient::write(const uint8_t * buffer, size_t size) {
    size_t written = 0;
    while (size > 0) {
        size_t toWrite = min(size, TFTP_DATA_SIZE - _writeBufferIndex);
        memcpy(_writeBuffer + _writeBufferIndex, buffer, toWrite);
        _writeBufferIndex += toWrite;
        buffer += toWrite;
        size -= toWrite;
        written += toWrite;

        if (_writeBufferIndex == TFTP_DATA_SIZE) {
            writeBlock(_writeBuffer, TFTP_DATA_SIZE);
            _writeBufferIndex = 0;
        }
    }

    return written;
}

void TFTPClient::flush() {
    writeBlock(_writeBuffer, _writeBufferIndex);
    stop();
}

int TFTPClient::writeBlock(const uint8_t* data, size_t dataSize) {
    if (!_uploadActive) {
        setError(-20, "No active upload");
        return -1;
    }
    
    if (_uploadComplete) {
        setError(-21, "Upload already completed");
        return -1;
    }
    
    if (!data || dataSize > TFTP_DATA_SIZE) {
        setError(-3, "Invalid data parameters");
        return -1;
    }
    
    // Send data packet
    bool packetSent = false;
    for (int retry = 0; retry <= _maxRetries; retry++) {
        if (sendDataPacket(_uploadServerIP, _uploadServerPort, _nextUploadBlock, data, dataSize)) {
            packetSent = true;
            break;
        }
        if (retry < _maxRetries) {
            delay(100);
        }
    }
    
    if (!packetSent) {
        setError(-22, "Failed to send data packet");
        return -1;
    }
    
    // Wait for ACK
    uint8_t packet[TFTP_PACKET_MAX_SIZE];
    size_t packetSize;
    IPAddress fromIP;
    uint16_t fromPort;
    
    bool ackReceived = false;
    for (int retry = 0; retry <= _maxRetries; retry++) {
        if (receivePacket(packet, packetSize, fromIP, fromPort, _timeout)) {
            if (fromIP == _uploadServerIP && fromPort == _uploadServerPort && packetSize >= 4) {
                uint16_t opcode = getUint16(packet);
                
                if (opcode == TFTP_ACK) {
                    uint16_t ackBlock = getUint16(packet + 2);
                    if (ackBlock == _nextUploadBlock) {
                        _totalBytesSent += dataSize;
                        _nextUploadBlock++;
                        
                        // If this block was less than 512 bytes, upload is complete
                        if (dataSize < TFTP_DATA_SIZE) {
                            _uploadComplete = true;
                        }
                        
                        return (int)dataSize;
                    }
                } else if (opcode == TFTP_ERROR) {
                    if (packetSize >= 5) {
                        uint16_t errorCode = getUint16(packet + 2);
                        _lastErrorCode = errorCode;
                        size_t msgLen = min((uint)packetSize - 4, (uint)sizeof(_lastErrorMessage) - 1);
                        memcpy(_lastErrorMessage, packet + 4, msgLen);
                        _lastErrorMessage[msgLen] = '\0';
                    } else {
                        setError(-23, "Server error during upload");
                    }
                    resetUploadState();
                    return -1;
                }
            }
        }
        
        // Resend data packet on timeout
        if (retry < _maxRetries) {
            sendDataPacket(_uploadServerIP, _uploadServerPort, _nextUploadBlock, data, dataSize);
        }
    }
    
    setError(-24, "Timeout waiting for ACK");
    return -1;
}

bool TFTPClient::endUpload() {
    if (_uploadActive) {
        resetUploadState();
        setError(0, "Upload ended");
        return true;
    }
    return false;
}

bool TFTPClient::isUploadActive() {
    return _uploadActive;
}

uint16_t TFTPClient::getCurrentUploadBlockNumber() {
    return _nextUploadBlock;
}

size_t TFTPClient::getTotalBytesSent() {
    return _totalBytesSent;
}

bool TFTPClient::sendAck(IPAddress serverIP, uint16_t port, uint16_t blockNumber) {
    uint8_t ackPacket[4];
    setUint16(ackPacket, TFTP_ACK);
    setUint16(ackPacket + 2, blockNumber);
    
    _udp.beginPacket(serverIP, port);
    size_t written = _udp.write(ackPacket, 4);
    return _udp.endPacket() && (written == 4);
}

bool TFTPClient::sendDataPacket(IPAddress serverIP, uint16_t port, uint16_t blockNumber, const uint8_t* data, size_t dataSize) {
    uint8_t packet[TFTP_PACKET_MAX_SIZE];
    
    // Build DATA packet: opcode (2) + block number (2) + data (0-512)
    setUint16(packet, TFTP_DATA);
    setUint16(packet + 2, blockNumber);
    
    if (dataSize > 0) {
        memcpy(packet + 4, data, dataSize);
    }
    
    size_t packetSize = 4 + dataSize;
    
    _udp.beginPacket(serverIP, port);
    size_t written = _udp.write(packet, packetSize);
    return _udp.endPacket() && (written == packetSize);
}

void TFTPClient::setError(int errorCode, const char* message) {
    _lastErrorCode = errorCode;
    strncpy(_lastErrorMessage, message, sizeof(_lastErrorMessage) - 1);
    _lastErrorMessage[sizeof(_lastErrorMessage) - 1] = '\0';
}

uint16_t TFTPClient::getUint16(const uint8_t* data) {
    return (data[0] << 8) | data[1];
}

void TFTPClient::setUint16(uint8_t* data, uint16_t value) {
    data[0] = (value >> 8) & 0xFF;
    data[1] = value & 0xFF;
}

bool TFTPClient::resolveHostname(const char* hostname, IPAddress& ip) {
    // Try to parse as IP address first
    if (ip.fromString(hostname)) {
        return true;
    }
    
    // Resolve hostname using WiFi
    if (WiFi.hostByName(hostname, ip)) {
        return true;
    }
    
    return false;
}
#pragma endregion
